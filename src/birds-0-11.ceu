^["@/pico/pico.ceu"]

val math-sin = func (v) {
    `:number sin($v.Number)`
}
val math-floor = func (v) {
    `:number floor($v.Number)`
}
val random-seed = func (n) {
    if n {
        `srand($n.Number);`
    } else {
        `srand(time(NULL));`
    }
}
val random-next = func () {
    `:number rand()`
}

pico-state-set-title        ("Birds - 11 (tracking)")
pico-state-set-size         ([640,480])
pico-state-set-size-pixel   ([1,1])
pico-state-set-grid         (false)
pico-state-set-color-clear  ([0,0,0,255])
pico-state-set-color-draw   ([255,255,255,255])

random-seed()

val WIN :XY = pico-state-get-size()

data :Bird = [alive,rect:Rect]

val Bird = task (t) :Bird {
    val y = t[0]
    val speed = t[1]
    set pub() = [true, [[(-WIN.x)/2,y], [100,90]]]
    var ang = 0
    val col? = spawn (task () :void {
        spawn (task () :void {
            spawn (task () :void {
                xloop {
                    val v = xloop { ;; AWAIT
                        xbreak if yield(nil) { as it :Pico.Frame =>
                            if is?(it, :Pico.Frame) {
                                it.ms * speed
                            } else {
                                false
                            }
                        }
                    }
                    set pub().rect.pos.x = pub().rect.pos.x + (v/1000)
                    set pub().rect.pos.y = y + ((speed/5) * math-sin(ang))
                    set ang = ang + ((3.14*v)/100000)
                }
            }) ()
            spawn (task () :void {
                xloop {
                    xloop { ;; AWAIT
                        xbreak if yield(nil) { as it =>
                            is?(it, :Pico.Draw)
                        }
                    }
                    if (math-floor(((ang+(3.14/2))/3.14)) % 2) == 0 {
                        pico-output-draw-image(pub().rect.pos, "res/clumsy_up.png");
                    } else {
                        pico-output-draw-image(pub().rect.pos, "res/clumsy_dn.png");
                    }
                }
            }) ()
            xloop {
                yield(nil) { as it => nil }
            }
        }) ()
        xloop {
            xbreak if yield(nil) { as it => it == :collided }
        }
    ;;;
        set task.pub.alive = false
        awaiting task.pub.rect.pos.y < -((WIN.y/2) - 45) {
            par {
                every :Pico.Frame {
                    set task.pub.rect.pos.y = task.pub.rect.pos.y - (evt.ms * 0.5)
                }
            } with {
                every :Pico.Draw {
                    pico-output-draw-image(task.pub.rect.pos, "res/clumsy_dn.png");
                }
            }
        }
        awaiting 1:s {
            loop {
                await 100:ms
                awaiting 100:ms {
                    every :Pico.Draw {
                        pico-output-draw-image(task.pub.rect.pos, "res/clumsy_dn.png");
                    }
                }
            }
        }
    ;;;
    }) ()
    xloop {
        xbreak if (pub().rect.pos.x > (WIN.x/2))
        xbreak if yield(nil) { as it => (it == col?) }
    }
}

spawn (task () {
    spawn (task () {
        ;;toggle :pause => :resume {
            val birds = tasks(5)
            spawn (task () {
                xloop {
                    var tot = 500
                    xloop {
                        xbreak if yield(nil) { as it =>
                            if is?(it,:frame) {
                                set tot = tot - it[0]
                                tot <= 0
                            } else {
                                false
                            }
                        }
                    }
                    val y = -(WIN.y/2) + (random-next() % WIN.y)
                    val s = 100 + (random-next() % 100)
                    spawn Bird([y,s]) in birds
                }
            }) ()
            spawn (task () {
                xloop {
                    xloop { ;; AWAIT
                        xbreak if yield(nil) { as it =>
                            is?(it, :Pico.Frame)
                        }
                    }
                    var b1 = nil
                    xloop {
                        set b1 = next(birds, b1)
                        xbreak if b1==nil
                        var b2 = nil
                        xloop {
                            set b2 = next(birds, b2)
                            xbreak if b2==nil
                            val col? =
                                detrack(b1) { as x1 :Bird =>
                                    detrack(b2) { as x2 :Bird =>
                                        (x1 /= x2)      &&
                                        (pub(x1).alive) &&
                                        (pub(x2).alive) &&
                                        pico-rect-vs-rect?(pub(x1).rect, pub(x2).rect)
                                    }
                                }
                            if col? {
                                broadcast(:collided) in b1
                                broadcast(:collided) in b2
                            } else {
                                nil
                            }
                        }
                    }
                }
            }) ()
            spawn (task () {
                yield(nil) { as it => nil }
                ;;;
                xloop {
                    val bird = catch true {
                        every :Pico.Mouse.Button.Dn {
                            loop b in :tasks birds {
                                if pico-point-vs-rect?(evt.pos, detrack(b).pub.(:Bird).rect) {
                                    throw(move(b))
                                }
                            }
                        }
                    }
                    awaiting bird {
                        every :Pico.Draw {
                            pico-output-draw-line([0,-240], detrack(bird).pub.(:Bird).rect.pos)
                        }
                    }
                }
                ;;;
            }) ()
            xloop {
                yield(nil) { as it => nil }
            }
        ;;}
    }) ()
    ;;;
    spawn (task () {
        loop {
            await :Pico.Key.Dn, (evt.key == :Key-P)
            broadcast :pause
            awaiting :Pico.Key.Dn, (evt.key == :Key-P) {
                every :Pico.Draw {
                    pico-output-draw-image([0,0], "res/pause.png");
                }
            }
            broadcast :resume
        }
    }) ()
    ;;;
    xloop {
        yield(nil) { as it => nil }
    }
}) ()

xloop {
    val e = resume pico-coro ()
    xbreak if do {
        if e {
            broadcast(e)
            is?(e, :Pico.Quit)
        } else {
            nil
        }
    }
}
