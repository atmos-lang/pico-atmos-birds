^["@/pico/pico.ceu"]

pico-state-set-title        <- "Birds - 11 (tracking)"
pico-state-set-size         <- [640,480]
pico-state-set-size-pixel   <- [1,1]
pico-state-set-grid         <- false
pico-state-set-color-clear  <- [0,0,0,255]
pico-state-set-color-draw   <- [255,255,255,255]

random-seed()

val WIN :XY = pico-state-get-size()

data :Bird = [alive,rect:Rect]

task Bird (y,speed) :Bird {
    set task.pub = [true, [[(-WIN.x)/2,y], [100,90]]]
    var ang = 0
    awaiting (task.pub.rect.pos.x > (WIN.x/2)) {
        awaiting (evt is? :collided) {
            par {
                every :Pico.Frame {
                    val v = evt.ms * speed
                    set task.pub.rect.pos.x = task.pub.rect.pos.x + (v/1000)
                    set task.pub.rect.pos.y = y + ((speed/5) * math-sin(ang))
                    set ang = ang + ((3.14*v)/100000)
                }
            } with {
                every :Pico.Draw {
                    if (math-floor(((ang+(3.14/2))/3.14)) % 2) == 0
                        => pico-output-draw-image(task.pub.rect.pos, "res/clumsy_up.png");
                        => pico-output-draw-image(task.pub.rect.pos, "res/clumsy_dn.png");
                }
            }
        }
        set task.pub.alive = false
        awaiting task.pub.rect.pos.y < -((WIN.y/2) - 45) {
            par {
                every :Pico.Frame {
                    set task.pub.rect.pos.y = task.pub.rect.pos.y - (evt.ms * 0.5)
                }
            } with {
                every :Pico.Draw {
                    pico-output-draw-image(task.pub.rect.pos, "res/clumsy_dn.png");
                }
            }
        }
        awaiting 1:s {
            loop {
                await 100:ms
                awaiting 100:ms {
                    every :Pico.Draw {
                        pico-output-draw-image(task.pub.rect.pos, "res/clumsy_dn.png");
                    }
                }
            }
        }
    }
}

spawn {
    par {
        toggle :pause => :resume {
            val birds = tasks(5)
            par {
                every 500:ms {
                    spawn in birds, Bird(y,s) where {
                        val y = -(WIN.y/2) + (random-next() % WIN.y)
                        val s = 100 + (random-next() % 100)
                    }
                }
            } with {
                every :Pico.Frame {
                    loop b1 in :tasks birds {
                        loop b2 in :tasks birds {
                            val ok = do {
                                val :tmp t1 :Bird = detrack(b1)
                                val :tmp t2 :Bird = detrack(b2)
                                (t1 /= t2) and
                                    ((t1 and t1.pub.alive) and
                                    ((t2 and t2.pub.alive) and
                                    pico-rect-vs-rect?(t1.pub.rect, t2.pub.rect)))
                            }
                            if ok {
                                broadcast in detrack(b1), :collided
                                broadcast in detrack(b2), :collided
                            }
                        }
                    }
                }
            } with {
                loop {
                    val bird = catch true {
                        every :Pico.Mouse.Button.Dn {
                            loop b in :tasks birds {
                                if pico-point-vs-rect?(evt.pos, detrack(b).(:Bird).pub.rect) {
                                    throw(move(b))
                                }
                            }
                        }
                    }
                    awaiting bird {
                        every :Pico.Draw {
                            pico-output-draw-line([0,-240], detrack(bird).(:Bird).pub.rect.pos)
                        }
                    }
                }
            }
        }
    } with {
        loop {
            await :Pico.Key.Dn, (evt.key == :Key-P)
            broadcast :pause
            awaiting :Pico.Key.Dn, (evt.key == :Key-P) {
                every :Pico.Draw {
                    pico-output-draw-image([0,0], "res/pause.png");
                }
            }
            broadcast :resume
        }
    }
}

pico-loop ()
