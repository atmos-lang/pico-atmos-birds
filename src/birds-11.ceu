^["pico.ceu"]

pico-state-set-title("Birds - 11 (tracking)")
pico-state-set-size([640,480])
pico-state-set-size-pixel([1,1])
pico-state-set-grid(false)
pico-state-set-color-clear([0,0,0,255])
pico-state-set-color-draw([255,255,255,255])

val WIN :XY = pico-state-get-size()

task Bird (y,speed) :Rect {
    set task.pub = [[(-WIN.x)/2,y], [100,90]]
    var sin = 0
    awaiting task.pub.pos.x > 320 {
        awaiting :collided {
            par {
                every :Pico.Frame {
                    val v = evt.0 * speed
                    set task.pub.pos.x = task.pub.pos.x + (v/1000)
                    set task.pub.pos.y = y + ((speed/5) * `:number sin($sin.Number)`)
                    set sin = sin + ((3.14*v)/100000)
                }
            } with {
                every :Pico.Draw {
                    if (`:number ((int)((($sin.Number+(3.14/2)))/3.14))` % 2) == 0 {
                        pico-output-draw-image(task.pub.pos, "res/clumsy_up.png");
                    } else {
                        pico-output-draw-image(task.pub.pos, "res/clumsy_dn.png");
                    }
                }
            }
        }
        awaiting task.pub.pos.y < -200 {
            par {
                every :Pico.Frame {
                    set task.pub.pos.y = task.pub.pos.y - (evt.0 * 0.5)
                }
            } with {
                every :Pico.Draw {
                    pico-output-draw-image(task.pub.pos, "res/clumsy_dn.png");
                }
            }
        }
        awaiting 1:s {
            par {
                while true {
                    broadcast in :task, :Hide []
                    await 100:ms
                    broadcast in :task, :Show []
                    await 100:ms
                }
            } with {
                toggle :Hide -> :Show {
                    every :Pico.Draw {
                        pico-output-draw-image(task.pub.pos, "res/clumsy_dn.png");
                    }
                }
            }
        }
    }
}

spawn {
    par {
        toggle :Pause -> :Resume {
            val birds = tasks(5)
            par {
                every 500:ms {
                    (spawn in birds, Bird(y,s)) where {
                        val y = (random-next() % 480) - 240
                        val s = 100 + (random-next() % 100)
                    }
                }
            } with {
                every :Pico.Frame {
                    while in :tasks birds, b1 {
                        while in :tasks birds, b2 {
                            if detrack(b1).status and (detrack(b1) /= detrack(b2)) {
                                if pico-rect-vs-rect?(detrack(b1).pub,detrack(b2).pub) {
                                    broadcast in detrack(b1), tags([], :collided, true)
                                    broadcast in detrack(b2), tags([], :collided, true)
                                }
                            }
                        }
                    }
                }
            } with {
                while true {
                    val bird = catch true {
                        every :Pico.Mouse.Button.Dn {
                            while in :tasks birds, b {
                                if pico-point-vs-rect?(evt.pos,detrack(b).pub) {
                                    throw(b)
                                }
                            }
                        }
                    }
                    awaiting bird {
                        every :Pico.Draw {
                            pico-output-draw-line([0,-240], detrack(bird).pub.0)
                        }
                    }
                }
            }
        }
    } with {
        while true {
            await :Pico.Key.Dn, (evt.key == :Key-P)
            broadcast in :global, :Pause []
            awaiting :Pico.Key.Dn, (evt.key == :Key-P) {
                every :draw {
                    pico-output-draw-image([0,0], "res/pause.png");
                }
            }
            broadcast in :global, :Resume []
        }
    }
}

pico-loop ()
