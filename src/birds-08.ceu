^["@/pico/pico.ceu"]

pico-state-set-title("Birds - 08 (fall)")
pico-state-set-size([640,480])
pico-state-set-size-pixel([1,1])
pico-state-set-grid(false)
pico-state-set-color-clear([0,0,0,255])
pico-state-set-color-draw([255,255,255,255])

val WIN :XY = pico-state-get-size()

data :Bird = [alive,rect:Rect]

task Bird (y,speed) :Bird {
    set task.pub = [true, [[(-WIN.x)/2,y], [100,90]]]
    var ang = 0
    awaiting (task.pub.rect.pos.x > (WIN.x/2)) {
        awaiting (evt is? :collided) {
            par {
                every :Pico.Frame {
                    val v = evt.ms * speed
                    set task.pub.rect.pos.x = task.pub.rect.pos.x + (v/1000)
                    set task.pub.rect.pos.y = y + ((speed/5) * math-sin(ang))
                    set ang = ang + ((3.14*v)/100000)
                }
            } with {
                every :Pico.Draw {
                    if (math-floor(((ang+(3.14/2))/3.14)) % 2) == 0 {
                        pico-output-draw-image(task.pub.rect.pos, "res/clumsy_up.png");
                    } else {
                        pico-output-draw-image(task.pub.rect.pos, "res/clumsy_dn.png");
                    }
                }
            }
        }
        set task.pub.alive = false
        awaiting task.pub.rect.pos.y < -((WIN.y/2) - 45) {
            par {
                every :Pico.Frame {
                    set task.pub.rect.pos.y = task.pub.rect.pos.y - (evt.ms * 0.5)
                }
            } with {
                every :Pico.Draw {
                    pico-output-draw-image(task.pub.rect.pos, "res/clumsy_dn.png");
                }
            }
        }
    }
}

spawn {
    val birds = tasks(5)
    par {
        every 500:ms {
            (spawn in birds, Bird(y,s)) where {
                val y = -(WIN.y/2) + (`:number rand()` % WIN.y)
                val s = 100 + (`:number rand()` % 100)
            }
        }
    } with {
        every :Pico.Frame {
            loop in :tasks birds, b1 {
                loop in :tasks birds, b2 {
                    val ok = do {
                        val t1 :Bird = detrack(b1)
                        val t2 :Bird = detrack(b2)
                        (t1 /= t2) and
                        ((t1 and t1.pub.alive) and
                        ((t2 and t2.pub.alive) and
                        pico-rect-vs-rect?(t1.pub.rect, t2.pub.rect)))
                    }
                    if ok {
                        broadcast in detrack(b1), :collided
                        broadcast in detrack(b2), :collided
                    }
                }
            }
        }
    }
}

pico-loop ()
