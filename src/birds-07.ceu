^["@/pico/pico.ceu"]

pico-state-set-title("Birds - 07 (iterator)")
pico-state-set-size([640,480])
pico-state-set-size-pixel([1,1])
pico-state-set-grid(false)
pico-state-set-color-clear([0,0,0,255])
pico-state-set-color-draw([255,255,255,255])

random-seed()

val WIN :XY = pico-state-get-size()

task Bird (y,speed) :Rect {
    set task.pub = [[(-WIN.x)/2,y], [100,90]]
    var ang = 0
    awaiting (evt is? :collided) or (task.pub.pos.x > (WIN.x/2)) {
        par {
            every :Pico.Frame {
                val v = evt.ms * speed
                set task.pub.pos.x = task.pub.pos.x + (v/1000)
                set task.pub.pos.y = y + ((speed/5) * math-sin(ang))
                set ang = ang + ((3.14*v)/100000)
            }
        } with {
            every :Pico.Draw {
                if (math-floor(((ang+(3.14/2))/3.14)) % 2) == 0 {
                    pico-output-draw-image(task.pub.pos, "res/clumsy_up.png");
                } else {
                    pico-output-draw-image(task.pub.pos, "res/clumsy_dn.png");
                }
            }
        }
    }
}

spawn {
    val birds = tasks(5)
    par {
        every 500:ms {
            (spawn in birds, Bird(y,s)) where {
                val y = -(WIN.y/2) + (random-next() % WIN.y)
                val s = 100 + (random-next() % 100)
            }
        }
    } with {
        every :Pico.Frame {
            loop in :tasks birds, b1 {
                loop in :tasks birds, b2 {
                    if status(detrack(b1)) and (detrack(b1) /= detrack(b2)) {
                        if pico-rect-vs-rect?(detrack(b1).pub,detrack(b2).pub) {
                            broadcast in detrack(b1), :collided
                            broadcast in detrack(b2), :collided
                        }
                    }
                }
            }
        }
    }
}

pico-loop ()
